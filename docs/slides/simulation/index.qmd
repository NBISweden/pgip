---
title: "Simulation"
subtitle: "Primer on the coalescent and forward simulation"
author:
    - "Per Unneberg"
format:
  revealjs:
    footer: Simulation primer
---

## Setup  {visibility="hidden" .unnumbered .unlisted}

{{< include ../_knitr.qmd >}}

{{< include ../_rlibs.qmd >}}

```{r libs}
#| echo: false
#| eval: true
#| cache: false
library(ape)
library(gganimate)
library(patchwork)
library(igraph)
library(ggraph)
library(tidygraph)
```

## The Wright-Fisher model and simulations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-1
#| echo: false
#| eval: true
#| fig-cap: Wright-Fisher model for 50 generations, 30 individuals
#| out-width: 80%
set.seed(132)
g <- wright_fisher_pop(n = 30, generations = 50)
x_range <- range(vertex_attr(g, "x"))
y_range <- range(vertex_attr(g, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 4, x_range[2])
g %>%
  mutate(
    allele =
      ifelse(degree(., mode = "out") > 0,
        "b", "a"
      )
  ) %>%
  ggplot_wf(., fill = allele) +
    geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

### Recap

Model of a population describing **genealogies** under the following assumptions

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

::: {.fragment}

**Forward** simulation

:::

:::

:::

::::

::: {.notes }

[p. 15 @hein2005gene] shows the fraction of genes without descendants.
Focus on the number of descendants for *one* gene *i*, which is X ~
Bin(2N, 1/2N). Since E(X)=1, for large 2N, X is almos Po(1), such that
P(no descendants) = P(X=0) = e^{-1}

Low reproductive success: forward simulations costly!

:::

## The Wright-Fisher model and simulations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-2
#| echo: false
#| eval: true
#| fig-cap: Wright-Fisher model for 50 generations, 30 individuals
#| out-width: 80%
set.seed(132)
g <- wright_fisher_pop(n = 30, generations = 50)
x_range <- range(vertex_attr(g, "x"))
y_range <- range(vertex_attr(g, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 4, x_range[2])
g %>%
  mutate(
    allele =
      ifelse(degree(., mode = "out") > 0,
        "b", "a"
      )
  ) %>%
  ggplot_wf(., fill = allele) +
    geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-graph
#| echo: false
#| eval: true
#| cache: false
#| fig-cap:
#|    Reproductive success in percent per generation.
#| out-width: 55%
gdf <- g %>%
  mutate(allele = ifelse(degree(., mode = "out") > 0, "b", "a")) %>%
  as.data.frame()
x <- tapply(gdf$allele, gdf$y, function(x) {
  sum(x == "b") / length(x)
})
xmean <- sprintf("%.1f%%", mean(x) * 100)
df <- data.frame(x = seq_along(x), y = x)
ggplot(subset(df, x < 50), aes(x = x, y = y * 100)) +
  geom_line(linewidth=1.2) +
  xlab("Generation") +
  ylab("Reproductive success (%)") +
  theme(text=element_text(size=36))
```

Mean reproductive success = `r sprintf("%.1f%%", mean(x) * 100)`. Can
show for large populations P(no descendants)=$1 - e^{-1} \approx
0.632$

:::

:::

::::

::: {.notes }

[p. 15 @hein2005gene] shows the fraction of genes without descendants.
Focus on the number of descendants for *one* gene *i*, which is X ~
Bin(2N, 1/2N). Since E(X)=1, for large 2N, X is almos Po(1), such that
P(no descendants) = P(X=0) = e^{-1}

Low reproductive success: forward simulations costly!

:::

## Forward and backward simulation

```{r }
#| label: wright-fisher-model-graph
#| echo: false
#| eval: true
#| cache: false
set.seed(2023)
wf <- wright_fisher_pop(n = 10, generations = 16)
```

:::: {.columns}

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-forward
#| echo: false
#| eval: true
#| fig-cap:
#|    Forward simulation.
#| out-width: 60%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "black"
  )) +
  geom_node_point(fill = "black", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
      geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-backward
#| echo: false
#| eval: true
#| fig-cap:
#|    Backward simulation.
#| out-width: 60%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
      geom_segment(
    aes(
      x = x1, y = y_range[2],
      xend = x1, yend = y_range[1]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

Simulated nodes are filled with black. Genealogy of interest is
highlighted in thick black lines.

## Why do we want simulations anyway?

::: {.incremental}

Null model
: Generate neutral null distributions to compare with observed data

Exploration
: Use to gain understanding and improve interpretation of mutational
  processes

Mathematical complexity
: No analytical solutions for linked selection and the like
  $\rightarrow$ must use simulations

Benchmarking
: Use to generate test data with known properties on which to test and
  evaluate new methods

Model training
: Generate training data for machine learning, e.g., Approximate
  Bayesian Computation (ABC) or Neural Networks (NNs)

:::

# The coalescent

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-1
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)
2. Simulate mutations

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-mutations
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)$mut <- ""
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
set.seed(23)
E(obj)[sample(E(obj)[.to(i)], 5)]$mut <- "*"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width, label=mut),
                 angle_calc="along", label_size=18) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)
2. Simulate mutations

Question: how many mutations are common to all samples? How many
mutations does sample 1 have? Sample 2?

Assuming the ancestral state is denoted `0` (prior to the *first*
generation) and the derived state `1`, what are the sequences of the
samples?

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-mutations-1
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)$mut <- ""
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
set.seed(23)
E(obj)[sample(E(obj)[.to(i)], 5)]$mut <- "*"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width, label=mut),
                 angle_calc="along", label_size=18) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-1
#| echo: false
#| eval: true
#| out-height: 600px
#| out-width: 500px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[leaf, right of=3, node distance=60px] (4) {}
node[leaf, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\useasboundingbox (t5l.south west) rectangle (t1r.north east);
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-2
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[leaf, right of=3, node distance=60px] (4) {}
node[leaf, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-3
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black,minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[selected, right of=3, node distance=60px] (4) {}
node[selected, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-4
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-5
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-6
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-7
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[selected] (1) {}
node[selected, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-8
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node[leaf] at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-9
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node[leaf] at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-10
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[leaf, above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
(8) -- (root)
(6) -- (root)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$$^1$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

::: {.smallr}

$^1$: The exponential can be parametrized in two different ways, so
that the parameter to the function is either $\lambda$ or
$\beta=1/\lambda$.

:::

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-11
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
(8) -- (root)
(6) -- (root)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$$^1$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

::: {.smallr}

$^1$: The exponential can be parametrized in two different ways, so
that the parameter to the function is either $\lambda$ or
$\beta=1/\lambda$.

:::

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: fig-simulate-genealogy-end
#| echo: false
#| eval: true
#| fig-cap:
#|   A simulated genealogy. The $T_i$ represent the
#|   waiting time when the state has $i$ chromosomes.
#| out-height: 600px
#| out-width: 500px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{tikzpicture}
```

:::

::::

## Some properties of the tree

:::: {.columns}

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: fig-genealogy-properties
#| echo: false
#| eval: true
#| fig-cap:
#|   A coalescent tree with numbered nodes. Nodes 1-5 correspond
#|   to the samples and are leaves. The internal nodes 6-8 (and the
#|   unlabelled root) are ancestral chromosomes (unsampled). The
#|   $T_i$ represent the waiting time when the state has $i$ chromosomes,
#|   whereas $\tau_i$ correspond to the branch length from node $i$
#|   to its parent.
#| out-height: 500px
#| out-width: 400px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          every label/.style={font=\sffamily\Large}
          ]

\draw
node[leaf, label={[yshift=-25pt]1}] (1) {1}
node[leaf, label={[yshift=-25pt]2}, right of=1, node distance=60px] (2) {2}
node[leaf, label={[yshift=-25pt]3}, right of=2, node distance=80px] (3) {3}
node[leaf, label={[yshift=-25pt]4}, right of=3, node distance=60px] (4) {4}
node[leaf, label={[yshift=-25pt]5}, right of=4, node distance=20px] (5) {5}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node[leaf, label={[xshift=10pt]7}] at ($(1) !.3! (root) $) (7) {7}
node[leaf, label={[xshift=10pt]8}] at ($(1) !.6! (root) $) (8) {8}
node[leaf, label={[xshift=10pt]6}] at ($(5) !.1! (root) $) (6) {6}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(1) !.5! (7) - (10pt, 0)$) () {$\mathbf{\tau_1}$}
node at ($(2) !.5! (7) - (10pt, 0)$) () {$\mathbf{\tau_2}$}
node at ($(3) !.45! (8) - (10pt, 0)$) () {$\mathbf{\tau_3}$}
node at ($(4) !.5! (6) - (10pt, 0)$) () {$\mathbf{\tau_4}$}
node at ($(5) !.5! (6) + (10pt, 0)$) () {$\mathbf{\tau_5}$}
node at ($(6) !.5! (root) + (10pt, 0)$) () {$\mathbf{\tau_6}$}
node at ($(7) !.5! (8) - (10pt, 0)$) () {$\mathbf{\tau_7}$}
node at ($(8) !.5! (root) - (10pt, 0)$) () {$\mathbf{\tau_8}$}
;


\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{tikzpicture}
```

:::

::: {.column width="50%"}

Expected waiting time to coalesce when $i$ lineages: $E(T_i) =
\frac{2}{i(i-1)}$

Branch lengths can be derived from waiting times. For instance,
$\tau_1=\tau_2=T_5+T_4$ and $\tau_4=\tau_5=T_5$

Time to the **most recent common ancestor (MRCA)**: $T_{MRCA} =
\sum_{i=2}^n T_i$

with expected value $E(T_{MRCA}) = \sum_{i=2}^nE(T_i) = 2\left(1 -
\frac{1}{n}\right)$

The expected **total tree height** is $E(T_{total}) = \sum_{i=2}^n
iE(T_i) = 2\sum_{i=2}^n\frac{1}{i-1}$

:::

::::

## Variation in topology and height

::: {style="transform:  translate(-300px, 0);"}

::: {style="transform: rotate(180deg);"}

```{r }
#| label: genealogy-variation
#| echo: false
#| eval: true
#| out-height: 500px
set.seed(20)
mykronoviz <- function(x, layout = length(x), ...) {
  par(mar = rep(0.5, 4), oma = rep(0, 4))
  rts <- sapply(x, function(x) branching.times(x)[1])
  maxrts <- max(rts)
  lim <- cbind(rts - maxrts, rts)
  Ntree <- length(x)
  Ntips <- sapply(x, Ntip)
  nrow <- 1
  w <- Ntips
  h <- 1
  layout(matrix(1:layout, nrow), widths = w, heights = h)
  for (i in 1:Ntree) {
    plot(x[[i]],
      y.lim = lim[i, ], direction = "u",
      ...
    )
  }
}
trees <- lapply(rep(5, 6), rcoal, simplify = FALSE)
mykronoviz(trees, type = "c", show.tip.label = FALSE, edge.width = 3)
```

:::

:::

## Diminishing returns of adding more samples

```{r }
#| label: coalescent-diminishing-returns
#| echo: false
#| eval: true
#| fig-width: 16
#| fig-height: 8
n <- 20
t_total <- function(n) {2*sum(1/(seq(2,n)-1))}
t_mrca <- function(n) {2*(1 - 1/n)}

data <- data.frame(y=c(c(0, unlist(lapply(2:n, t_total))),
                       c(0, unlist(lapply(2:n, t_mrca)))),
                       x=c(1:n, 1:n),
                       stat=c(rep("E[T_total]", n), rep("E[T_MRCA]", n))
                       )
ggplot(data, aes(x=x, y=y, linetype=factor(stat))) +
  geom_line(linewidth=1.2) + xlab("n") + ylab("") +
  guides(linetype=guide_legend(title="Statistic"))
```

## Adding mutations

```{tikz, fig.ext="svg" }
#| label: fig-add-mutations
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 500px
#| fig-cap:
#|   Adding mutations on a coalescent genealogy.
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=10pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=120px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=80px] (4) {}
node at ($(1) !.5! (4)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(4) !.6! (root) $) (6) {}
node at ($(2) !.5! (6) $) (5) {}
node[above of=root, node distance=10px, outer sep=10px] (ancestral) {00000}
node[below of=1, rotate=60, node distance=8px, anchor=south east] (l1) {11000}
node[below of=2, rotate=60, node distance=8px, anchor=south east] (l2) {00110}
node[below of=3, rotate=60, node distance=8px, anchor=south east] (l3) {00100}
node[below of=4, rotate=60, node distance=8px, anchor=south east] (l4) {00001}
node at ($(1) !.33! (root) - (.5, 0)$) (m1l) {0}
node at ($(1) !.33! (root) + (.5, 0)$) (m1r) {1}
node at ($(1) !.67! (root) - (.5, 0)$) (m2l) {0}
node at ($(1) !.67! (root) + (.5, 0)$) (m2r) {1}
node at ($(2) !.5! (5) - (.5, 0)$) (m3l) {0}
node at ($(2) !.5! (5) + (.5, 0)$) (m3r) {1}
node at ($(5) !.5! (6) - (.5, 0)$) (m4l) {0}
node at ($(5) !.5! (6) + (.5, 0)$) (m4r) {1}
node at ($(4) !.5! (6) - (.5, 0)$) (m5l) {0}
node at ($(4) !.5! (6) + (.5, 0)$) (m5r) {1}
;
\draw
(1) -- (root)
(4) -- (root)
(2) -- (6)
(3) -- (5);
\draw[>=latex, ->] (m1l) -- (m1r);
\draw[>=latex, ->] (m2l) -- (m2r);
\draw[>=latex, ->] (m3l) -- (m3r);
\draw[>=latex, ->] (m4l) -- (m4r);
\draw[>=latex, ->] (m5l) -- (m5r);

\end{tikzpicture}
```

## The coalescent and diversity {.smaller}

:::: {.columns}

::: {.column width="50%"}

```{r, engine="tikz", fig.ext="svg" }
#| label: coalescent-tree-dna-variation
#| echo: false
#| eval: true
#| out-height: 600
\begin{tikzpicture}[outer sep=0, inner sep=0, thick,
                    node distance=5px, every node/.style={font=\ttfamily}]
\tikzstyle{mut} = [circle, minimum height=0.2cm, fill=gray, draw];
\draw
node (1) at (0, 0) {}
node (2) at (1, 0) {}
node (3) at (2, 0) {}
node (4) at (3, 0) {}
node (5) at ($(1) !.5! (2) + (0, 2)$) {}
node (6) at ($(1-|5) !.5! (3) + (0, 3)$) {}
node (7) at ($(1-|6) !.5! (4) + (0, 5)$) {}
node[above of=7, anchor=south] (rootl) {000000}
node[rotate=45, below left of=1, anchor=north east] (1l) {010100}
node[rotate=45, below left of=2, anchor=north east] (2l) {010100}
node[rotate=45, below left of=3, anchor=north east] (3l) {001000}
node[rotate=45, below left of=4, anchor=north east] (4l) {100011}
;

\draw
(1) -- (5)
(2) -- (5)
(5) -- (6)
(3) -- (6)
(6) -- (7)
(4) -- (7)
node[mut] (m1) at ($(5) !.33! (6)$) {}
node[mut] (m2) at ($(5) !.67! (6)$) {}
node[mut] (m3) at ($(3) !.5! (6)$) {}
node[mut] (m4) at ($(4) !.25! (7)$) {}
node[mut] (m5) at ($(4) !.5! (7)$) {}
node[mut] (m6) at ($(4) !.75! (7)$) {}
;
\end{tikzpicture}
```

:::

::: {.column width="50%"}

Many statistical quantities can be related to the **site frequency
spectrum** (**SFS**), which is a summary of the frequencies of the
segregating sites. Let $\xi_i$ be the number of chromosomes in the
sample with $i$ minor alleles. In the figure we have 6 mutations on
$n=4$ chromosomes.

|         | Name      | Count |
|---------|-----------|-------|
| $\xi_1$ | singleton | 4     |
| $\xi_2$ | doubleton | 2     |
| $\xi_3$ |           | 0     |

Note that the number of segregating sites is $S=\sum_{i=1}^{n-1}\xi_i$

In this notation one can show that $\pi$, the nucleotide diversity, is

$$
\pi = \frac{\sum_{i=1}^{n-1}i(n-i)\xi_i}{n(n-1)/2}
$$

::: {.fragment}

#### Exercise

Calculate the nucleotide diversity and compare the results from the foundation lecture

:::

::: {.fragment}

$$
\pi = \frac{1(4-1)\xi_1 + 2(4-2)\xi_2 + 3(4-3)\xi_3}{4(4-1)/2} =
\frac{1}{6}\left(12 + 8 + 0\right) = 3\frac{1}{3}
$$

:::

:::

::::

::: {.notes }

Point out that we record the number of mutations per branch which together with

:::

## The impact of topology on the SFS

:::: {.columns}

::: {.column width="50%"}

<!-- markdownlint-disable MD013 -->

![Interpretation of neutrality tests [@ferretti_DecomposingSiteFrequency_2017]](assets/images/ferretti-table1.jpg){width=480}

<!-- markdownlint-enable MD013 -->

:::

::: {.column width="50%"}

<!-- markdownlint-disable MD013 -->

![The SFS under neutrality and selection](assets/images/nielsen-fig2-2005.jpeg){width=480}

<!-- markdownlint-enable MD013 -->

Many tests for selection are based on the SFS which in turn is
influenced by the topology of the tree.

:::

::::

::: {.notes }

Take home: topologies influence shape of SFS

### Example: Tajima's D

Tests common versus rare alleles. Numerator compares nucleotide
diversity $\pi$ to Watterson's theta, $\theta_W$.

D < 0
: recent population increase *or* positive selection

D > 0
: population contraction *or* balancing selection

:::

# Exercise on the coalescent {.unnumbered .unlisted}

# The coalescent with recombination

## On non-recombining chromosomes and assortment

:::: {.columns}

::: {.column width="50%"}

```{r, engine="tikz", fig.ext="svg" }
#| label: non-recombining-chromosomes-assortment-1
#| echo: false
#| eval: true
#| out-width: 300
\tikzstyle{female}=[circle,thick,minimum size=1cm,draw=black]
\tikzstyle{male}=[rectangle,thick,minimum width=1cm, minimum height=1cm, draw=black]
  \begin{tikzpicture}[>=latex,font=\small, thick,
    plab/.style={font=\scriptsize, outer sep=0cm}]
    \node[male, fill=gray] (grandfather) at (0, 8) { };
    \node[female] (grandmother) at (4, 8) { };

\node[inner sep=0cm] (grandparents) at (2, 8) { };

    \node[male, fill=gray] (father) at (2, 4) { };
    \node[female] (mother) at (6, 4) { };

\node[inner sep=0cm] (parents) at (4, 4) { };
\node[inner sep=0cm] (siblings) at (4, 2) { };

    \node[female, fill=gray] (sister1) at (2, 0) { };
    \node[female, fill=gray] (sister2) at (6, 0) { };

\draw (grandfather) -- (grandmother);
\draw (grandparents) -- (father);
\draw (parents) -- (siblings);
\draw (father) -- (mother);
\draw (siblings) -| (sister1);
\draw (siblings) -| (sister2);
\end{tikzpicture}
```

Both siblings inherit chromosome from paternal grandfather

Chromosomes coalesce at father

:::

::: {.column width="50%"}

::: {.fragment}

```{r, engine='tikz', fig.ext='svg' }
#| label: non-recombining-chromosomes-assortment-2
#| echo: false
#| eval: true
#| out-width: 300
\usetikzlibrary{shapes}
\tikzstyle{female}=[circle,thick,minimum size=1cm,draw=black]
\tikzstyle{male}=[rectangle,thick,minimum width=1cm, minimum height=1cm, draw=black]
\tikzstyle{splitmale}=[rectangle split, rectangle split
                       parts=2,thick,minimum width=1cm, minimum
                       height=1cm, draw=black]
  \begin{tikzpicture}[>=latex,font=\small, thick,
    plab/.style={font=\scriptsize, outer sep=0cm}]
    \node[male, fill=gray] (grandfather) at (0, 8) { };
    \node[female, fill=lightgray] (grandmother) at (4, 8) { };

\node[inner sep=0cm] (grandparents) at (2, 8) { };

\node[splitmale, rotate=90, rectangle split part fill={gray,
  lightgray}] (father) at (2, 4) { };
    \node[female] (mother) at (6, 4) { };

\node[inner sep=0cm] (parents) at (4, 4) { };
\node[inner sep=0cm] (siblings) at (4, 2) { };

    \node[female, fill=gray] (sister1) at (2, 0) { };
    \node[female, fill=lightgray] (sister2) at (6, 0) { };

\draw (grandfather) -- (grandmother);
\draw (grandparents) -- (father);
\draw (parents) -- (siblings);
\draw (father) -- (mother);
\draw (siblings) -| (sister1);
\draw (siblings) -| (sister2);
\end{tikzpicture}
```

Siblings inherit different grandparental chromosomes $\Rightarrow$
chromosomes coalesce God knows when in the past

Genealogies **differ**

:::

:::

::::

## The ancestral recombination graph

:::: {.columns}

::: {.column width="50%"}

![The ancestral recombination graph,
[@hubisz_InferenceAncestralRecombination_2020, Fig.
1]](assets/images/hejase-2020-fig1.jpg){width=400}

:::

::: {.column width="50%"}

Properties:

- marginal trees constitute a sequence of trees (**tree sequence**)
  along a chromosome
- each tree represents the genealogy of a non-recombining part of the
  chromosome
- neighbouring trees are **correlated**

Interpretation: chromosomes are mosaics of non-recombining units

:::

::::

## msprime stores variation data as tree sequences

:::: {.columns}

::: {.column width="50%"}

![Tree sequences [@kelleher_EfficientPedigreeRecording_2018, Fig. 3]](assets/images/kelleher-plos-2018-fig3.png){width=500}

:::

::: {.column width="50%"}

![Data compression [@kelleher_InferringWholegenomeHistories_2019, Fig. 1c]](assets/images/kelleher-nature-2019-fig1c.png){width=600}

:::

::::

## Simulating ancestry with msprime

<!-- markdownlint-disable MD013 -->

From [msprime
quickstart](https://tskit.dev/msprime/docs/stable/quickstart.html)

<!-- markdownlint-enable MD013 -->

```{python }
#| label: sim_ancestry
#| echo: true
#| eval: true
#| fig-format: svg
#| output: asis
#| out-width: 300
import msprime
# Simulate an ancestral history for 3 diploid samples under the coalescent
# with recombination on a 5kb region with human-like parameters.
ts = msprime.sim_ancestry(
    samples=3,
    recombination_rate=1e-8,
    sequence_length=5_000,
    population_size=10_000,
    random_seed=123456)
print(ts.draw_svg())
```

## Simulating mutations with msprime

```{python }
#| label: sim_mutations
#| echo: true
#| eval: true
#| output: asis
#| fig-format: svg
import msprime
ts = msprime.sim_ancestry(
    samples=3,
    recombination_rate=1e-8,
    sequence_length=5_000,
    population_size=10_000,
    random_seed=123456)
mutated_ts = msprime.sim_mutations(ts, rate=1e-8, random_seed=54321)
print(mutated_ts.draw_svg())
```

# msprime exercise {.unnumbered .unlisted}

## Bibliography {.unnumbered .unlisted}

::: { #refs }
:::
