---
title: "Population genetics"
subtitle: "Foundations"
author:
    - "Per Unneberg"
format:
  revealjs:
    footer: Population genetics foundations
---

## Setup  {visibility="hidden" .unnumbered .unlisted}

{{< include ../_knitr.qmd >}}

{{< include ../_rlibs.qmd >}}

```{r libs}
#| echo: false
#| eval: true
#| cache: false
library(viridislite)
library(gganimate)
library(patchwork)
library(expm)
library(gridExtra)
library(igraph)
library(ggraph)
library(tidygraph)
```

::: {.notes }

:::

# DNA variation

::: {.notes }

Goal of section: look at the data that forms the foundation for
population genomic analyses

From [@nei_MolecularEvolutionPhylogenetics_2000, p. 231]:

> The main subject of population genetics is to study the generation
> and maintenance of genetic polymorphism and to understand the
> mechanisms of evolution at the population level

[@casillas_MolecularPopulationGenetics_2017, p. 1026]:

> Big data samples of complete genome sequences of many individuals
> from natural populations of many species have transformed population
> genetics inferences on samples of loci to population genomics: the
> analysis of genome-wide patterns of DNA variation within and between
> species.

[@gillespie_PopulationGeneticsConcise_2004, p. 1]

> Population geneticists spend most of their time doing one of two
> things: describing the genetic structure of populations or
> theorizing on the evolutionary forces acting on populations

:::

## DNA variation

::: {.dna .small}

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|:--:|:--:|:--:|:--:|:--:|
| T | T | A | C | A | A | T | C | C | G  | A  | T  | C  | G  | T  |
| T | T | A | C | G | A | T | G | C | G  | C  | T  | C  | G  | T  |
| T | C | A | C | A | A | T | G | C | G  | A  | T  | G  | G  | A  |
| T | T | A | C | G | A | T | G | C | G  | C  | T  | C  | G  | T  |

: Sequence aligmnent of four DNA sequences
  [@hahn_MolecularPopulationGenetics_2019, Fig 1.1].
  {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

The main data for molecular population genetics are DNA sequences. The
alignment above shows a *sample* of four DNA *sequences*. Each
sequence has 15 nucleotides (*sites*) "from the same *locus*
(location) on a chromosome" [p.2
@hahn_MolecularPopulationGenetics_2019]

:::: {.columns}

::: {.column width="60%"}

::: {.fragment}

Alternative names for *sequence*:

:::

:::: {.columns}

::: {.column width="50%"}

::: {.incremental}

- *chromosome*
- *gene*

:::

:::

::: {.column width="50%"}

::: {.incremental}

- *allele* (different by origin)
- *sample*
- *cistron*

:::

:::

::::

:::

::: {.column width="40%"}

::: {.fragment}

We will preferentially use *sequence* or *chromosome* to refer to an
entire sequence, and *allele* to refer to individual nucleotides that
differ.

:::

:::

::::

## DNA variation - monomorphic sites

::: {.dna }

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|:--:|:--:|:--:|:--:|:--:|
| T | T | A | C | A | A | T | C | C | G  | A  | T  | C  | G  | T  |
| T | T | A | C | G | A | T | G | C | G  | C  | T  | C  | G  | T  |
| T | C | A | C | A | A | T | G | C | G  | A  | T  | G  | G  | A  |
| T | T | A | C | G | A | T | G | C | G  | C  | T  | C  | G  | T  |
| * |   | * | * |   | * | * |   | * | *  |    | *  |    | *  | T  |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

The alignment has 4 DNA sequences where each sequence has length
$L=15$. A site where all nucleotides (alleles) are identical is called
a *monomorphic* site (indicated with asterisks above). There are 9
monomorphic sites.

## DNA variation - segregating sites

::: {.dna }

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

A site where there are different nucleotides (alleles) is called a
*segregating* site (indicated with asterisks above), often denoted
*S*. There are $S=6$ segregating sites.

:::: {.columns}

::: {.column width="50%"}

::: {.fragment}

Alternative names for *segregating site* are:

:::

::: {.incremental}

- *polymorphism*
- *mutation*
- *single nucleotide polymorphism (SNP)*

:::

:::

::: {.column width="50%"}

::: {.fragment}

*mutation* here and onwards refers to the process that generates new
variation and the new variants generated by this process

In contrast to *mutation* which corresponds to within-species
variation, a *substitution* refers to DNA differences between species.

:::

:::

::::

## DNA variation - major and minor alleles

::: {.dna }

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

Much of the nucleotide variation we study consists of *bi-allelic*
SNPs. The most common variant is called the *major* allele, and the
least common the *minor* allele.

The set of alleles found on a single sequence is called *haplotype*.

## Describing DNA variation - heterozygosity {.smaller}

::: {.dna }

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

Once we have a sample of sequences we want to describe the observed
variation. At any position the *i*th allele has sample frequency
$p_i$, where the sum of all allele frequencies is 1. For instance, at
site 1, $p_T=1$ (and by extension $p_A=p_C=p_G=0$), and at site 2
$p_C=1/4$ and $p_T=3/4$.

::: {.notes }

::: {.dna }

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|:--:|:--:|:--:|:--:|:--:|
| T | T | A | C | A | A | T | C | C | G  | A  | T  | C  | G  | T  |
| T | T | A | C | G | A | T | G | C | G  | C  | T  | C  | G  | T  |
| T | C | A | C | A | A | T | G | C | G  | A  | T  | G  | G  | A  |
| T | T | A | C | G | A | T | G | C | G  | C  | T  | C  | G  | T  |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,25]"}

:::

:::

:::: {.columns}

::: {.column width="50%"}

::: {.fragment}

#### Heterozygosity

The *heterozygosity* at a site $j$ is given by

$$
h_j = \frac{n}{n-1}\left(1 - \sum_i p_i^2\right)
$$

where the summation is over all alleles and $p_i$ is the frequency of
the $i$-th allele

:::

:::

::: {.column width="50%"}

::: {.fragment}

#### Exercise: calculate the heterozygosity at sites 1, 2 and 5

:::

::: {.fragment}

<!-- markdownlint-disable MD013 -->

$$
h_1 = \frac{4}{3} \left(1 - p_T^2 \right) = 0 \\
h_2 = \frac{4}{3} \left(1 - \left(p_C^2 + p_T^2\right) \right) = \frac{4}{3} \left( 1 - \left(\frac{1}{16} + \frac{9}{16}\right)\right) = \frac{1}{2}\\
h_5 = \frac{4}{3} \left(1 - \left(p_A^2 + p_G^2\right) \right) = \frac{4}{3} \left( 1 - \left(\frac{1}{4} + \frac{1}{4}\right)\right) = \frac{2}{3}
$$

<!-- markdownlint-enable MD013 -->

:::

:::

::::

## Describing DNA variation - nucleotide diversity

::: {.dna }

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

:::: {.columns}

::: {.column width="50%"}

::: {.fragment}

### Nucleotide diversity $\pi$

The *nucleotide diversity* is the sum of site heterozygosities:

$$
\pi = \sum_{j=1}^S h_j
$$

where $S$ is the number of segregating sites

:::

:::

::: {.column width="50%"}

::: {.fragment}

### Calculate the nucleotide diversity

:::

::: {.fragment}

Observation: $h_i$ either 1/2 or 2/3 (for sites with
$p_{major}=p_{minor}$).

:::

::: {.fragment}

<!-- markdownlint-disable MD013 -->

$$
\pi = \frac{1}{2} + \frac{2}{3} + \frac{1}{2} + \frac{2}{3} + \frac{1}{2} + \frac{1}{2} = 3\frac{1}{3}
$$

<!-- markdownlint-enable MD013 -->

:::

::: {.fragment}

Often we provide $\pi$ per site:

$$
\pi = 3.33/15 = 0.222
$$

:::

:::

::::

## In absence of evolutionary forces alleles are in equilibrium

### The Hardy-Weinberg equilibrium

For a locus, let $A$ and $a$ be two different alleles and let $p$
be the frequency of the $A$ allele and $q=1-p$ the frequency of the
$a$ allele. In the **absence** of **mutation**, **drift**,
**migration**, and other evolutionary processes, the equilibrium state
is given by the **Hardy-Weinberg equilibrium** (**HWE**).

|            |       |       |       |
|------------|-------|-------|-------|
| Genotype:  | $AA$  | $Aa$  | $aa$  |
| Frequency: | $p^2$ | $2pq$ | $q^2$ |

Importantly, under the HWE assumption, we can calculate allele
frequencies from genotype frequencies and vice versa:

$$
p = p^2 + pq\\
q = q^2 + pq
$$

::: {.notes }

Segue: apart from describing the variation we want to model how allele
frequencies *change* in time. As
[@gillespie_PopulationGeneticsConcise_2004, preface p. xi] points out,
"While genotype frequencies are easily measured, their change is not"

:::

::: {.notes }

Segue: describing variation fine, but where does it come from and how does it change?

If assumptions of HWE hold, we have no change of variation. However,
we **want** to look at **change** of variation and disentangle the
forces that imposes change

:::

## Natural populations do mate randomly?

```{r }
#| label: fig-hwe-1000genomes
#| echo: false
#| eval: true
#| fig-height: 6
#| fig-width: 12
#| fig-cap:
#|     Hardy-Weinberg proportions in 10,000 SNPs on chromosome
#|     22 from three populations based on 1000 genomes data.
#|     Illustration inspired by @cooplab_PopulationGeneticsCourse_2011
pops <- c("CEU", "CHB", "YRI")
fn <- file.path("data/Homo_sapiens/1000g/genotypes", paste0(pops, ".22:17000000-20000000.hwe.gz"))
names(fn) <- pops
x <- do.call(
    "rbind", lapply(pops, function(p) {
      y <- cbind(population=p, read.table(fn[[p]], header=TRUE))
      geno <- do.call("rbind", lapply(strsplit(y$GENO, "/"), as.numeric))
      n <- round(nrow(geno)/2)
      geno <- rbind(geno[1:n,], geno[(n+1):nrow(geno), 3:1])
      colnames(geno) <- c("AA.cnt", "Aa.cnt", "aa.cnt")
      geno.frq <- as.data.frame(geno / apply(geno, 1, sum))
      colnames(geno.frq) <- c("AA", "Aa", "aa")
      allele.frq <- as.data.frame(cbind(geno.frq$AA + 0.5*geno.frq$Aa,
                                        geno.frq$aa + 0.5*geno.frq$Aa))
      colnames(allele.frq) <- c("p", "q")
      cbind(y, geno, geno.frq, allele.frq)
    }))
x <- pivot_longer(x, cols=c("AA", "Aa", "aa"), names_to="genotype")
p <- seq(0, 1, 0.01)
n <- 10000
z <- do.call("rbind", by(x, x$population, function(y) {
  y[sample(nrow(y), 10000),]}))

vend <- 0.8
cols.hwe <- c(viridis_pal(end=vend)(3), "black", "black")
lt.hwe <- c(rep("blank", 3), "dashed", "solid")
shape.hwe <- c(rep(16, 3), NA, NA)
cnames <- c("aa", "Aa", "AA", "Hardy Weinberg Expectation", "Mean")
names(cols.hwe) <- cnames
names(lt.hwe) <- cnames
names(shape.hwe) <- cnames

ggplot(z, aes(x=p, y=value)) +
  geom_point(size=2, alpha=.6, aes(color=genotype)) +
  geom_smooth(method="loess", linewidth=1, show.legend=TRUE,
              lty="dashed", aes(group=genotype, color="Mean")) +
  geom_line(inherit.aes=FALSE, aes(x=p, y=p**2,
                                   color="Hardy Weinberg Expectation")) +
  geom_line(inherit.aes=FALSE, aes(x=p, y=2*p*(1-p),
                                   color="Hardy Weinberg Expectation")) +
  geom_line(inherit.aes=FALSE, aes(x=p, y=(1-p)**2,
                                   color="Hardy Weinberg Expectation")) +
  xlab("allele frequency") + ylab("genotype frequency") +
  facet_grid(. ~ population) + scale_color_viridis_d(end=vend) +
  scale_color_manual(name=NULL, values=cols.hwe,
                     guide = guide_legend(
                         override.aes = list(
                             linetype = lt.hwe,
                             shape = shape.hwe
                         )))
```

::: {.notes }

<!-- markdownlint-disable MD013 -->

See
<https://stackoverflow.com/questions/26587940/ggplot2-different-legend-symbols-for-points-and-lines>
for legend customization.

<!-- markdownlint-enable MD013 -->

:::

## The obsession of population genetics

Population genetics is about [@gillespie_PopulationGeneticsConcise_2004]

1. describing the genetic structure of populations
2. constructing theories on the forces that influence genetic
   variation

::: {.fragment}

Questions to ponder:

- why does variation look the way it does?
- how is variation maintained?
- how does variation change over time ($\Delta p$)?
- what forces shape the genetic structure of *populations*?

:::

::: {.notes }

From HWE: we want to look a the creation, maintenance and loss of
variation and what forces affect it

Goal: describe theory behind evolving populations. This has been an
obsession for a long time, even before DNA was known -> back to basics

:::

# Models of populations

::: {.notes }

Segue: take a step back to the days before the nature of genetic
inheritance was known. First focus on the population.

Goal of lecture is also to understand genetic relationships in the
context of genealogies -> coalescent.

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

::: {.incremental}

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

:::

:::

::: {.column width="50%"}

:::

::::

::: {.notes }

See @hein_GeneGenealogies_2004 for more assumptions. The second
assumption means we can use 2N chromosome interchangeably for haploid
(n=2N) and diploid (n=N) populations.

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero

:::

::: {.column width="50%"}

```{r }
#| label: wright-fisher-model-graph
#| echo: false
#| eval: true
#| cache: false
set.seed(2023)
wf <- wright_fisher_pop(n = 10, generations = 16)
```

```{r }
#| label: wf-1
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
y_range <- range(V(wf)$y)
ggplot_wf(wf %>% filter(y == 0), y_range = y_range) +
  ggtitle("Starting population")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one

:::

::: {.column width="50%"}

```{r }
#| label: wf-2
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
wf %>%
  filter(y >= 0 & y <= 1) %E>%
  filter(from <= -1) %>%
  ggplot_wf(., y_range = y_range) + ggtitle("Offspring")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.0
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to == 11) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.1
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% c(11, 12)) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.1b
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% c(11:13)) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.2
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:18) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:20) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3-untangled
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:20) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents (untangled)")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-4
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 7
#| fig-width: 7
wf %>%
  filter(y >= 0 & y <= 2) %>%
  mutate(allele = ifelse(degree(., mode = "out") > 0 & y == 1, "b", "a")) %>%
  ggplot_wf(., y_range = y_range, fill = allele) + ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

```{r }
#| label: fig-wright-fisher-model-gganimation
#| echo: false
#| eval: true
#| aniopts: width=1000,controls=all
#| fig-show: animate
#| fig-keep: all
#| fig-cap: Wright-Fisher model
#| out-width: 14
popsize <- max(V(wf)$x) + 1
generations <- max(V(wf)$y) + 1
for (t in 3:generations) {
  obj <- wf %E>% filter(to <= (t * popsize)) %N>% filter(y >= 0 & y <= t)
  print(ggplot_wf(obj, y_range = y_range) + ggtitle(paste("Generation", t)))

  obj <- wf %N>%
    filter(y >= 0 & y <= t) %>%
    mutate(allele = ifelse(degree(., mode = "out") > 0 & y == (t - 1), "b", "a")) %E>%
    filter(to <= (t * popsize))

  print(ggplot_wf(obj, y_range = y_range, fill = allele) +
    ggtitle(paste("Generation", t)))

  obj <- wf %N>%
    filter(y >= 0 & y <= t) %>%
    mutate(allele = ifelse(degree(., mode = "out") > 0 & y == (t - 1), "b", "a")) %E>%
    filter(to <= ((t + 1) * popsize))

  print(ggplot_wf(obj, y_range = y_range, fill = allele) +
    ggtitle(paste("Generation", t)))
}
```

::: {.notes }

See <https://mikeyharper.uk/animated-plots-with-r/>

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="40%"}

```{r }
#| label: fig-wright-fisher-model-gganimation-last
#| echo: false
#| eval: true
#| fig-cap: |
#|   WF model indicating time
#|   direction from past (top) to present
#|   (bottom).
#| out-width: 100%
x_range <- range(vertex_attr(wf, "x"))
y_range <- range(vertex_attr(wf, "y"))
x1 <- x_range[1] - 0.5
x_range <- c(x1 - 2, x_range[2])
wf %>% ggplot_wf(.) +
  geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - .5, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = 0,
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = 15,
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="40%"}

::: {.fragment}

```{r}
#| label: fig-wf-model-genealogy
#| echo: false
#| eval: true
#| fig-cap: "WF model tracing the genealogies of three extant genes"
obj <- wf
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(fill = "white", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3))
```

:::

:::

::::

## The Wright-Fisher sampling model

Let's formalise the sampling process of the Wright-Fisher model^[For a
more extensive treatment, see
@hermisson_MathematicalPopulationGenetics_2017 or @hein2005gene]. We
assume

1. a single locus in a haploid population of size $2N$ (or diploid of
   size $N$ when random mationg)
2. no mutation and selection
3. discrete generations

Each generation we sample $2N$ new chromosomes from the previous
generation. The probability of choosing a chromosome $v$ is $1/2N$
(coin flip with probability of success $1/2N$). Since the trials are
independent, and we perform $2N$ trials, the number of offspring of a
given chromosome $v$ is *binomially distributed* $\mathrm{Bin}(m, p)$,
with parameters $m=2N$ and probability of success $p=\frac{1}{2N}$:

$$
P(v=k) = {2N\choose k}\left( \frac{1}{2N} \right)^k
\left(1 - \frac{1}{2N} \right)^{(2N - k)}
$$

## Properties of Wright-Fisher sampling

### The expected number of offspring is one

<br>

```{r, engine='tikz', fig.ext='svg' }
#| label: wf-expected-number-of-offspring
#| echo: false
#| eval: true
#| fig-align: center
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1} {
  \foreach \x in {1,2,3,4,5} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
}
\draw[->] (n13) -- (n03);
\draw[->, dotted] (n13) -- (n02);
\draw[->, dotted] (n13) -- (n04);
\node[lab, above of=n13] {$v$};
\end{tikzpicture}
```

<br>

$$
E(v) = mp = 2N\frac{1}{2N} = 1
$$

## Properties of Wright-Fisher sampling

### Poisson approximation for large $N$

<br>

```{r, engine='tikz', fig.ext='svg' }
#| label: wf-poisson-approximation-large-n
#| echo: false
#| eval: true
#| fig-align: center
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1} {
  \foreach \x in {1,2,3,4,5,8,9,10} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {6, 6.5, 7} {\node[cdot] at (\x, \y) {};}
}
\draw[->] (n13) -- (n03);
\draw[->] (n13) -- (n02);
\draw[->] (n13) -- (n04);
\node[lab, above of=n13] {$v$};
\node[lab, above of=n11] {$1$};
\node[lab, above of=n110] {$2N$};
\end{tikzpicture}
```

<br>

When $2N$ large it holds that the probability that sequence $v$ has
$k$ offspring is

$$
P(v=k) \approx \frac{1}{k!}e^{-k}
$$

Since $P(v=0) = e^{-1} \approx 0.37$, a fraction 0.37 of sequences lack
descendants

## Properties of Wright-Fisher sampling

### Probability that two sequences pick same parent

```{r, engine="tikz", fig.ext="svg" }
#| label: wf-prob-parents-identical-fig
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 800
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{u} = [fill=black];
  \tikzstyle{v} = [fill=gray];
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.3cm, inner sep=0];
\foreach \y in {0, 2} {
  \foreach \x in {1,2,3,4,5,6,7,8,9,12,13,14,15} {
    \node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {10, 10.5, 11} {\node[cdot] at (\x, \y) {};}
}
\node[lab, above of=n21] {1};
\node[lab, above of=n215] {2N};
\node[lab, below of=n03] {u};
\node[lab, below of=n06] {v};
\node[lab, above of=n23] {$p_u=p_v$};
\node[lab, above of=n26] {$p_u \neq p_v$};
\node[lab, above of=n213] {$p_u \neq p_v$};
\draw[->] (n03) -- (n23);
\path[->] (n06) edge node[above right] {$\frac{1}{2N}$} (n23);
\path[->] (n06) edge[dotted] node[right] {$1-\frac{1}{2N}$} (n26);
\path[->] (n06) edge[dotted] node[above left] {$1-\frac{1}{2N}$} (n213);
\end{tikzpicture}
```

Let $u$ and $v$ be two sequences. Pick a parent $p_u$ of $u$. Then the
probability that $v$ picks the same parent is (solid lines)

$$
P(p_u=p_v) = \frac{1}{2N}
$$

The probability that they pick different parents is

$$
P(p_u \neq p_v) = 1 - \frac{1}{2N}
$$

## Properties of Wright-Fisher sampling {.smaller}

### Time for two sequences to coalesce

:::: {.columns}

::: {.column width="25%"}

:::

::: {.column width="50%"}

```{r, engine="tikz", fig.ext="svg" }
#| label: fig-wf-two-chrom-find-common-ancestor
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 70%
#| fig-cap: Illustration of two sequences finding a
#|     common ancestor after five generations; four failures
#|     with probability $1-1/2N$, one success with probability
#|     1/2N
\begin{tikzpicture}[>=latex,thick]
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{u} = [fill=black];
  \tikzstyle{v} = [fill=gray];
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1,2,3,4,5} {
  \foreach \x in {1,2,3,4,7,8} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {5, 5.5, 6} {\node[cdot] at (\x, \y) {};}
}
\node[lab, above of=n51] {1};
\node[lab, above of=n58] {2N};
\node[lab, below of=n02] {u};
\node[lab, below of=n04] {v};
\draw[->] (n02) -- (n11);
\draw[->] (n11) -- (n22);
\draw[->] (n22) -- (n32);
\draw[->] (n32) -- (n43);
\draw[->] (n43) -- (n53);
\draw[->] (n04) -- (n14);
\draw[->] (n14) -- (n23);
\draw[->] (n23) -- (n33);
\draw[->] (n33) -- (n44);
\draw[->] (n44) -- (n53);

\node at ($(n01) !.5! (n11) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n11) !.5! (n21) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n21) !.5! (n31) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n31) !.5! (n41) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n41) !.5! (n51) - (1, 0)$) {$\frac{1}{2N}$};
\end{tikzpicture}
```

:::

::: {.column width="25%"}

:::

::::

Time for two sequences $u$ and $v$ to find common ancestor
distributed as $(1 - \frac{1}{2N})^{j-1}\frac{1}{2N}$ ($j-1$ failures
followed by success). This is the [geometric
distribution](https://en.wikipedia.org/wiki/Geometric_distribution)
$Ge(p)$, with parameter $p=\frac{1}{2N}$, and expected value
$\frac{1}{p}={2N}$. That is, the **expected number of generations for
two sequences to find a common ancestor (i.e., coalesce) is $2N$
generations**.

::: {.notes }

Since a large fraction of genes lack descendants, very quickly
(compared to 2N) a population will descend from a small proportion of
genes.

Derivation of average time to having same parent (i.e., coalescence)
requires knowledge of geometric distribution. The probability that the
genes find common parent $j$ generations ago is

$$
(1-\frac{1}{2N})^{(j-1)}\frac{1}{2N}
$$

due to independence between generations. This is the geometric
distribution $Ge(p)$ with $p=1/2N$, which has expected value $1/p$,
i.e., 2N in this case.

:::

# Origin and change of variation

## Genetic drift with alleles

:::: {.columns .compact}

::: {.column width="35%" }

```{r }
#| label: wright-fisher-drift-0.3-1
#| echo: false
#| eval: true
#| cache: false
set.seed(1974)
g <- wright_fisher_pop(n = 10, generations = 16, p0 = 3)
ggplot_wf(g, fill = allele) + ggtitle("Allele fixation") +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

::: {.column width="35%" .fragment}

```{r }
#| label: wright-fisher-drift-0.3-2
#| echo: false
#| eval: true
#| cache: false
set.seed(2014)
g <- wright_fisher_pop(n = 10, generations = 16, p0 = 0.3)
ggplot_wf(g, fill = allele) + ggtitle("Allele loss") +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

Wright-Fisher model showing the evolution of population of 10 genes
over 16 generations. Allele variants are shown in white and black.
Starting frequency black variant is 0.3.

::::

::: {.notes }

Enter allelic variants; we are looking at two variants

Important: point out that the fate of any allele under drift is to be
**lost** or **fixed**, which ultimately means variation is **lost**
with drift

:::

## Sampling model again

```{r }
#| label: allele-sampling-model
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 3
#| fig-width: 12
#| fig-align: center
set.seed(901)
wf <- wright_fisher_pop(n = 20, generations = 2, p0=0.3)
y_range <- range(V(wf)$y)
ggplot_wf(wf, fill=allele)
```

We assume two gene variants $A$, $a$, each with $i$ and $j=2N-i$
copies in generation $t$. Let $p_t=i/2N$ be the *frequency* of $A$ in
generation $t$, and $q_t=1-p_t$ the frequency of $a$.

The sampling model for next generation $t+1$ is then

$$
p_{t+1} = P(v_A=k) = {2N\choose k}\left( \frac{i}{2N} \right)^k
\left(1 - \frac{i}{2N} \right)^{(2N - k)} = \mathsf{Bin}(2N, \frac{i}{2N})
$$

::: {.notes }

NB: we here slightly change notation, with $p_{t+1} = P(X=k)$ p

:::

## Genetic drift

:::: {.columns}

::: {.column width="50%"}

To capture dynamics, follow allele frequency trajectory as function of
time.

::: {.smallr}

```{r code=readLines("../../../src/R/pgip/R/wright_fisher.R")}
#| label: wright-fisher-source
#| echo: true
#| eval: false
```

:::

::: {.fragment fragment-index=2}

Note dependency of variance on population size 2N

:::

:::

::: {.column width="50%" .fragment fragment-index=1}

```{r }
#| label: genetic-drift-example
#| echo: false
#| eval: true
#| cache: false
set.seed(1223)
n_reps <- 50
n_gen <- 100
conditions <- 4
p0 <- rep(c(0.01, 0.1, 0.5, 0.8), each = conditions)
N <- rep(c(50, 100, 1000, 5000), conditions)
sample <- rep(seq(1, n_reps), length(N))
p0_long <- rep(p0, each = n_reps)
N_long <- rep(N, each = n_reps)

wf <- mapply(wright_fisher, p0_long, N_long, n_gen, SIMPLIFY = FALSE)
wf <- data.frame(
  frequency = unlist(wf), N = rep(N_long, each = n_gen),
  generation = seq(1, n_gen), sample = rep(sample, each = n_gen),
  p0 = rep(p0_long, each = n_gen)
)
wf$N <- factor(wf$N)
wf$sample <- factor(wf$sample)
```

```{r }
#| label: fig-genetic-drift-N-10
#| echo: false
#| eval: true
#| fig-show: animate
#| fig-keep: all
#| out-width: 60%
#| fig-cap: |
#|    Genetic drift for different population sizes,
#|    starting frequency $p_0$=0.5
ggplot(
  subset(wf, wf$sample == 1 & wf$p0 == 0.5),
  aes(x = generation, y = frequency)
) +
  geom_line(size = 1) +
  xlim(1, 100) +
  ylim(0, 1) +
  facet_wrap(. ~ N) +
  transition_reveal(generation)
```

:::

::::

::: {.notes }

Mention *neutral* here as this is how alleles behave under
drift: like gas particle diffusing up and down. Allele is eventually either fixed or lost.

:::

## Genetic drift

:::: {.columns}

::: {.column width="50%"}

<!-- markdownlint-disable MD013 -->

```{r }
#| label: fig-genetic-drift-many-repetitions
#| echo: false
#| eval: true
#| fig-height: 8
#| fig-width: 12
#| out-height: 380
#| out-width: 560
#| fig-cap: |
#|   Genetic drift for different combinations of starting
#|   frequency and population size for n=50 repetitions per parameter
#|   combination. Note how variation and time to fixation depends on
#|   population size and starting frequency.
ggplot(wf, aes(x = generation, y = frequency, group = sample)) +
  geom_line() +
  xlim(1, 100) +
  ylim(0, 1) +
  facet_grid(N ~ p0)
```

<!-- markdownlint-enable MD013 -->

:::

::: {.column width="50%"}

::: {.incremental}

- fate of allele: fixation or loss $\rightarrow$ eventually loss of
  variation
- **probability of fixation $\pi(p)=p$**, where $p$ is the *current*
  frequency
- rate of drift (loss of variation) $\propto \frac{1}{2N}$

:::

::: {.fragment}

::: {.center}

```{r, engine='tikz', fig.ext="svg" }
#| label: gas-particle-drift
#| echo: false
#| eval: true
#| out-height: 200
#| fig-align: center
\begin{tikzpicture}
\node[circle, fill=black] (n) {};
\node[above of=n] (drift_up) {};
\node[below of=n] (drift_down) {};
\draw[->, >=latex] (n) -- node[right] {drift} (drift_down);
\draw[->, >=latex] (n) -- node[right] {drift} (drift_up);
\end{tikzpicture}
```

:::

:::

:::

::::

::: {.fragment}

Mathematical treatment of drift can become complicated: easier to
study dynamics of *heterozygosity*

:::

::: {.notes }

Simplifying assumptions -> rate of drift $propto \frac{1}{N}$
[@leffler_RevisitingOldRiddle_2012]

In reality population fluctuates and therefore Ne is substituted for
N. Larger Ne -> smaller fluctuation in allele frequency (as evidenced
in plots) -> maintain larger genetic diversity

:::

## Genetic drift as allele frequency distributions

```{r }
#| label: genetic-drift-histogram
#| echo: false
#| eval: true
n <- 10
x <- vector(mode="numeric", length=n + 1)
# Start with n major = n minor
n_a <- ceiling(length(x)/2)
x[n_a] <- 1
class <- c("absorbing", rep("normal", n - 1), "absorbing")
# Make transition matrix
P <- do.call("rbind", lapply(0:n, function(i) {dbinom(0:n, n, i/n)}))

plot_drift_histogram <- function(t, P) {
  data <- t(x %*% (P%^%t))
  xlabels <- unlist(lapply(0:n, function(x) {
    sprintf("frac(%i, %i)", x, n)
  }))
  p <- data.frame(n=0:n, class=class, obs=data) %>%
    ggplot(aes(y=obs, x=n, fill=class)) +
    geom_bar(stat="identity", color="black", width=1) +
    xlab("") + ylab("") +
    annotate("text", label = paste("t =", t), fontface="italic",
             x = n/2, y = 1.2*max(data), size = 10) +
    scale_fill_manual(values=list("absorbing"="black", "normal"="white")) +
    theme(legend.position="none",
          axis.text.y = element_text(size=16),
          axis.text.x = element_text(size=16, angle=0, hjust=0.5, vjust=0)) +
    scale_x_continuous(
        breaks=0:n,
        labels=do.call(c, lapply(xlabels, function(l) {parse(text=l)}))) +
    ylim(c(0, 1.3*max(data)))
  p
}
```

:::: {.columns}

::: {.column width="40%"}

```{r }
#| label: fig-genetic-drift-histogram-plot
#| echo: false
#| eval: true
#| fig-cap: Histogram @kimura_1983, Fig. 3.4
grid.arrange(
    plot_drift_histogram(t=1, P=P),
    plot_drift_histogram(t=5, P=P),
    plot_drift_histogram(t=10, P=P),
    plot_drift_histogram(t=20, P=P),
    ncol=2)
```

:::

::: {.column width="60%"}

```{r }
#| label: fig-buri-table-14
#| echo: false
#| eval: true
#| out-width: 70%
#| fig-width: 12
#| fig-height: 12
#| fig-cap: Buri experiment
data <- read.csv("assets/data/buri-table14.csv", header=TRUE, fill=0)
colnames(data)[3:35] <- as.character(0:32)
data <- data %>% replace(., is.na(.), 0)
data$`32` <- data$`32` + data$Total.fixed.bw.75
data$`0` <- data$`0` + data$Total.fixed.bw
plot_buri <- function(t, xaxis=FALSE, yaxis=FALSE, title=TRUE) {
  labels <- lapply(0:32, function(x) {
    ""
  })
  names(labels) <- as.character(0:32)
  labels$`0` <- 0
  labels$`32` <- 1
  p <- ggplot(stack(subset(data[2:20,c(1, 2:36)], Generation==t)[ , 3:35]),
              aes(x=ind, y=values)) +
    geom_bar(stat="identity") +
    theme(legend.position="none",
          axis.ticks=element_blank(),
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          plot.margin = unit(c(0, 0, 0, 0), "null"),
          panel.spacing = unit(c(0, 0, 0, 0), "null")) +
    ylab("") + xlab("") + ylim(0, 30)
  if (title) {
    p <- p + annotate("text", label = paste("t =", t), fontface="italic",
                      x = 2, y = 28, size = 8)
  }
  if (xaxis)  {
    p <- p + scale_x_discrete(breaks=0:32, labels=labels) +
      xlab("Frequency") +
      theme(axis.text.x = element_text(size=16, angle=0,
                                       hjust=0.5, vjust=0))
  }
  if (yaxis) {
    p <- p + ylab("Count") +
      theme(axis.text.y = element_text(size=16))
  }
  p
}
grid.arrange(
    plot_buri(1),# plot_buri(2), plot_buri(3),
    plot_buri(5),# plot_buri(5), plot_buri(6),
    plot_buri(10),# plot_buri(8), plot_buri(9),
    plot_buri(15),# plot_buri(11), plot_buri(12),
    plot_buri(19),
    ncol=1, padding=0
)
```

:::

::::

## Heterozygosity dynamics

:::: {.columns}

::: {.column width="50%"}

```{r, engine='tikz', fig.ext="svg" }
#| label: fig-identity-by-state-and-descent
#| echo: false
#| eval: true
#| out-width: 70%
#| fig-cap:
#|     Illustration of identity by descent (IBD) and state (IBS).
#|     Alleles in generation $n$ are IBD but not IBS.
\begin{tikzpicture}
\node (n_2) {$n-2$};
\node[right of=n_2] (nl0) {};
\node[right of=nl0] (n0) {\ttfamily-aac-};
\node[right of=n0] (nr0) {};
\node[below of=nl0,anchor=north] (n1) {\ttfamily-aac-};
\node[below of=nr0,anchor=north] (n2) {\ttfamily-aac-};
  \node[below of=n1,anchor=north] (n3) {\ttfamily-aac-};
  \node[below of=n2,anchor=north] (n4) {\ttfamily-aag-};
  \node[left of=n1] (nm1) {$n - 1$};
  \node[left of=n3] {$n$};
  \draw[->] (n0) -- (n1);
  \draw[->] (n0) -- (n2);
  \draw[->] (n1) -- (n3);
  \draw[->] (n2) -- (n4);
\end{tikzpicture}
```

:::

::: {.column width="50%"}

Let $\mathcal{H}_t$ be the probability that two alleles are
**different by state**. The time course evolution of $\mathcal{H}_t$
in a randomly mating population consisting of $N$ diploid
hermaphroditic individuals is

$$
\mathcal{H}_t = \mathcal{H}_0 \left( 1 - \frac{1}{2N} \right)^t
$$

Important consequence: heterozygosity in WF population lost at rate
$1/2N$.

:::

::::

::: {.notes }

Alleles in generation $n$ are IDB but not IBS

Motivation: mathematical description of genetic drift complicated for
populations with more than one individual. Easier to study the
evolution of heterozygosity.

:::

## Heterozygosity dynamics

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-gillespie-2.4
#| echo: false
#| eval: true
#| fig-cap:
#|    Plot of $\mathcal{H}_t$ illustrating how loss depends
#|    on population size
#| out-width: 70%
het_t <- function(N=1, t=0:100, H0=1) {
  H0 * (1 - 1/(2*N))^t
}
tmax <- 100
t <- 0:tmax
data <- data.frame(
    population_size = c(
        rep(1, length(t)),
        rep(10, length(t)),
        rep(100, length(t)),
        rep(1e6, length(t))),
    het = c(het_t(N=1), het_t(N=10), het_t(N=100), het_t(N=1e6)),
    tn = rep(t, 4)
)
ggplot(data, aes(x=tn, y=het, shape=factor(population_size))) +
  geom_point(size=3) + geom_line() + xlab("generation") +
  ylab("heterozygosity") + guides(shape=guide_legend(title="Size"))
```

:::

::: {.column width="50%"}

::: {.fragment}

```{r }
#| label: fig-black-footed-ferret
#| echo: false
#| eval: true
#| out-width: 70%
#| fig-cap: Heterozygosity in black-footed ferret [@wisely_GeneticDiversityFitness_2002]
# cf: https://github.com/cooplab/popgen-notes/blob/master/Journal_figs/genetic_drift/black_footed_ferrets/black-footed-ferrets_He.csv
data <- data.frame(date=c(1891, 1972, 1985, 1986),
                   He=c(0.231284916, 0.210335196,
                        0.101396648, 0.067877095),
                   N=c("N>10k", "N=62", "N=40", "N=7")
                   )
ggplot(data, aes(x=date, y=He, label=N)) + geom_line() + geom_point() +
  xlab("year") + ylab("heterozygosity") + geom_text(nudge_y=.005, nudge_x=2)
```

:::

:::

::::

## Effective population size

Assumptions underlying Wright-Fisher model seldom fulfilled for natural populations. In particular

- non-random mating (population structure)
- fluctuations of population census size

Therefore, magnitude of drift experienced by a population different
from that predicted by population size

Technically correct definition (but see @waples_WhatNeAnyway_2022):

> $N_e$ is the size of an ideal population that would experience the
> same rate of genetic drift as the population in question.

::: {.notes }

ideal population: discrete generations with random mating, no
evolutionary forces besides drift, no selective advantages

:::

## Mutation

:::: {.columns}

::: {.column width="60%"}

Genetic drift "moves" frequencies to the point that variation is lost
via allele fixation or loss. New variation is introduced through
**mutation**. We typically assume mutations are described by a Poisson
process with rate $\mu$ (per generation).

::: {.fragment}

The **mutation rate** is denoted $\mu$, and the **population scaled**
mutation rate is $2N_e\mu$ for haploid populations, $4N_e\mu$ for
diploid, where $N_e$ is the **effective population size**.

:::

::: {.fragment}

The **mutation - drift balance** is when the diversity lost due to drift
equals the diversity gained due to mutation.

:::

:::

::: {.column width="40%"}

::: {.fragment}

```{r }
#| label: fig-wf-mutation
#| echo: false
#| eval: true
#| fig-height: 15
#| fig-width: 12
#| out-height: 500px
#| out-width: 400px
#| fig-cap: |
#|   Variation is introduced by mutations (black) at rate $\mu=1e^{-4}$
#|   and is  occasionally lost through genetic drift.
set.seed(1212)
wf <- wright_fisher_pop(n = 40, generations = 30, mu = 0.0001)
ggplot_wf(wf, fill = allele) +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

:::

::::

::: {.notes }

Segue: so if drift removes variation, what introduces it? Mutation!

:::

## Models of mutation

<!-- markdownlint-disable MD013 -->

```{r, engine='tikz', fig.ext="svg" }
#| label: mutation-models
#| echo: false
#| eval: true
\usetikzlibrary{fit,decorations.pathreplacing}

\begin{tikzpicture}[
  every matrix/.style={matrix of nodes, ampersand replacement=\&,
    nodes in empty cells},
  every node/.style={text height=1.5ex},
  ]
\tikzstyle{sequence} = [black, font=\sffamily, column sep={.5cm,between origins}]
  \matrix(seq)[sequence] at (0,0)
  {
    T \& T \& A \& C \& A \& A \& T \& C \& C \& G \& A \& T \& C \& G \& C\\
    T \& T \& A \& C \& G \& A \& T \& G \& C \& G \& C \& T \& C \& G \& C\\
    T \& C \& A \& C \& A \& A \& T \& G \& C \& G \& A \& T \& G \& G \& A\\
     T \& T \& A \& C \& G \& A \& T \& G \& C \& G \& C \& T \& C \& G \& T\\
  };
\node[fit={(seq-1-2.north west) (seq-4-2.south east)}, inner sep=0, draw=black]{};
\node[fit={(seq-1-15.north west) (seq-4-15.south east)}, inner sep=0, draw=black]{};
\node[above of=seq-1-2, node distance=1.2cm] (two-allele) {Two-allele model};
\draw (seq-1-2.north) -- (two-allele);
\node[above of=seq-1-15, node distance=1.2cm] (finite) {Finite sites model};
\draw (seq-1-15.north) -- (finite);
\draw[decorate,decoration={brace,raise=0.2cm}] (seq-1-15.north east) -- (seq-4-15.south east);
\node at ($(seq-3-15) !.5! (seq-2-15)$) (seq-right) {};
\node[anchor=west, text width=1cm, right of=seq-right, node distance=1.2cm] (infinite-alleles) {Inifinite alleles model};
\node at ($(seq-4-1) !.5! (seq-4-15)$) (seq-low) {};
\draw[decorate,decoration={brace,mirror,raise=0.2cm}] (seq-4-1.south west) -- (seq-4-15.south east);
\node[below of=seq-low, node distance=.8cm] (infinite-sites) {Inifinite sites model};
\end{tikzpicture}
```

::: {.fragment}

```{r, engine='tikz', fig.ext='svg' }
#| label: stepwise-mutation-model
#| echo: false
#| eval: true
#| out-width: 1000px
\begin{tikzpicture}[
  every matrix/.style={matrix of nodes, ampersand replacement=\&,
    nodes in empty cells},
  every node/.style={text height=2ex},
  ]
  \tikzstyle{sequence} = [black, font=\sffamily, column sep={1.5cm,between origins},row sep={.7cm}]
  \matrix(seq)[sequence] at (0,0)
  {
$\mathsf{A}_{i-3}$ \&  $\mathsf{A}_{i-2}$ \&  $\mathsf{A}_{i-1}$ \& $\mathsf{A}_{i}$ \&  $\mathsf{A}_{i+1}$ \&  $\mathsf{A}_{i+2}$ \& $\mathsf{A}_{i+3}$ \\
  \&   \&  \&   \&   \&  \&  \\
  };
\draw[<->] (seq-1-1) -- (seq-1-2);
\draw[<->] (seq-1-2) -- (seq-1-3);
\draw[<->] (seq-1-3) -- (seq-1-4);
\draw[<->] (seq-1-4) -- (seq-1-5);
\draw[<->] (seq-1-5) -- (seq-1-6);
\draw[<->] (seq-1-6) -- (seq-1-7);
\node[left of=seq-1-1, node distance=0.7cm] {...};
\node[right of=seq-1-7, node distance=0.7cm] {...};
\draw[thick] (seq-2-1.south) -- (seq-2-1.north)
(seq-2-2.south) -- (seq-2-2.north)
(seq-2-3.south) -- (seq-2-3.north)
(seq-2-4.south) -- (seq-2-4.north)
(seq-2-5.south) -- (seq-2-5.north)
(seq-2-6.south) -- (seq-2-6.north)
(seq-2-7.south) -- (seq-2-7.north);

\draw[thick] (seq-2-1.west) -- (seq-2-7.east);
\node[above of=seq-1-4] {Stepwise mutation model};
\end{tikzpicture}
```

:::

<!-- markdownlint-enable MD013 -->

::: {.notes }

Model B: mainly for repeats

:::

## Tracing the evolution of mutations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-tracing-evolution-of-mutations
#| echo: false
#| eval: true
#| fig-height: 15
#| fig-width: 15
#| out-height: 500
#| out-width: 500
#| fig-cap: |
#|   Different mutations suffer different fates.
#|   Most mutations are lost in a couple of
#|   generations. Mutant alleles are colored
#|   black and their genealogies are highlighted
#|   with thicker edges.
j <- wf %E>%
  filter(.N()$allele[from] == "a" & .N()$allele[to] == "A") %>%
  pull(., to)
V(wf)$m0 <- V(wf)$allele
cliques <- ego(wf,
  order = attr(wf, "generations"),
  nodes = j, mode = "out"
)
wf %>%
  mutate(clique = .N()$m0 != "a") %E>%
  mutate(width = (0.2 + as.integer(.N()$allele[from] != "a"))) %N>%
  ggplot_wf(fill = clique, node_color = "lightgray")
```

:::

::: {.column width="50%"}

::: {.fragment}

Observation: most mutations are in fact lost

:::

::: {.fragment}

Recall: fixation probability $\pi(p)=p$

:::

:::

:::

::::

::: {.notes }

Difference to previous figure: here we highlight the genealogies

:::

## Mutation drift balance

Drift removes variation. Mutation reintroduces it. At equilibrium the
change in variation by definition is 0. In terms of $\mathcal{H}_t$
(the probability that two alleles are *not* identical by state),
$\Delta\mathcal{H}=0$.

One can show^[see [@gillespie_PopulationGeneticsConcise_2004, p.29 --
31] for a concise treatement] the classical formula that the
equilibrium **heterozysity** value is

$$
\hat{\mathcal{H}} = \frac{4N_e\mu}{1 + 4N_e\mu}
$$

::: {.fragment}

$\mu$ is often assumed known, and heterozygosity is easily calculated
from data, which provides a way of estimating $N_e$.

:::

::: {.fragment}

The compound parameter $4N_e\mu$ is called the **population scaled
mutation rate** and is commonly named $\theta$ such that

$$
\hat{\mathcal{H}} = \frac{\theta}{1 + \theta}
$$

:::

## The neutral theory of evolution

:::: {.columns}

::: {.column width="40%"}

Mutation drift balance, together with the observation during 50's-60's
that polymorphism was more common than expected, is the foundation of
the **neutral theory** of evolution: allele frequencies may change and
fix due to chance alone and not selection.

::: {.fragment}

**Nearly neutral theory** later developed to explain failure to
predict scaling of polymorphism with population size.

:::

:::

::: {.column width="60%"}

```{r }
#| label: fig-heterozygosity-function-ne
#| echo: false
#| eval: true
#| out-width: 60%
#| fig-cap:
#|     Heterozygosity predicted by the neutral theory.
#|     Shaded region shows typical heterozygosities in animals.
#|     $N_e\mu$ range is higher than predicted from plot.
#|     From @hurst_GeneticsUnderstandingSelection_2009, Fig 1.
NeMu <- c(
    seq(0.001, 0.999, 0.001),
    seq(1, 9.9, 0.1),
    seq(10, 100, 1)
)
ticks <- data.frame(x = c(trans_breaks("log10", function(x) 10^x)(c(0.001, 100)),
                          0.01483, 0.0567))
data <- data.frame(NeMu=NeMu,
                   H=4*NeMu / (1 + 4*NeMu))
ggplot(data, aes(x=NeMu, y=H)) + geom_line() +
  scale_x_continuous(trans="log10",
                     breaks = ticks$x,
                     labels = function(x) ifelse(x==0, "0", x),
                     expand = c(0, 0)) +
  scale_y_continuous(
      breaks = c(seq(0, 1, 0.1), 0.056, 0.185),
      labels = function(x) ifelse(x==0, "0", x),
      expand=c(0,0)) +
  ylab("Heterozygosity (H)") + xlab(expression(N[e]~mu)) +
  geom_rect(inherit.aes=FALSE,
            data = data.frame(xstart = c(0.01483, 0.01483), xend = c(0.0567, 0),
                              ystart = c(0, 0.056), yend = c(0.185, 0.185)),
                              aes(xmin = xstart, xmax = xend,
                                  ymin = ystart, ymax = yend,
                                  fill = "red"), alpha = 0.4,
            show.legend=FALSE)
```

:::

::::

::: {.notes }

Related to rate of substitution and molecular evolution is the work of
Kimura that lead to the development of the neutral theory.

Motivation: if polymorphic sites deleterious, should not expect much
polymorphism.

Low levels of polymorphism expected assuming little balancing
selection [@hurst_GeneticsUnderstandingSelection_2009, p. 87]; however
electrophoretic studies showed polymorphism common. Would lead to
detrimental load [@kimura_ProteinPolymorphismPhase_1971] -> therefore
majority of polymorphism must evolve neutrally (dynamics). Also: rate
of evolution (on protein level) too high (Haldane's dilemma)

:::

## Molecular evolution and rate of substitution

Mutation enters populations and may be fixed by drift. Therefore, with
time there will be fixed differences, or **substitions** (typically in
the evolution of species) between populations, or species. In
molecular evolution, the **substition rate**, **$\rho$**, is the most
interesting quantity.

::: {.fragment}

The total number of new mutations in every generation is $2N\mu$
(total number of gametes times mutation rate)

:::

::: {.fragment}

New mutations fix at a rate $1/2N$

:::

::: {.fragment}

Therefore, the **average rate of substitution**, **$\rho$**, is $2N\mu\times1/2N$, or

$$
\rho=\mu
$$

which is independent of population size!

:::

::: {.notes }

On $2N\mu$: the larger the population, the larger the number of
mutations that can fix

If $4N\mu>>0$ no new mutations can fix. Issue here is there is no
explicit mention of DNA sequence -> introduction of infinite sites
model

:::

# Selection

::: {.notes }

For a list of methods see <https://methodspopgen.com/methods-to-detect-selection/>

:::

## Selection {.smaller}

> Much confusion exists in the literature regarding how various types
> of selection are defined, in particular because some of the
> terminology is used slightly differently within different scientific
> communities [@nielsen_MolecularSignaturesNatural_2005]

$$
\begin{matrix}
\mathrm{Genotype} & aa & aA & AA \\
\mathrm{Frequency\ in\ newborns} & p^2 & 2pq & q^2\\
\mathrm{Viability} & w_{aa} & w_{aA} & w_{AA}\\
\mathrm{Frequency\ after\ selection} & p^2w_{aa} / \bar{w} &
    2pqw_{Aa} / \bar{w} & q^2w_{AA} / \bar{w} \\
\mathrm{Relative\ fitness} & 1 & 1-hs & 1-s\\
\end{matrix}
$$

where $\bar{w} = p^2w_{aa} + 2pqw_{Aa} + q^2w_{AA}$ is the **mean
fitness**

<br/>

|         |                                        |
|---------|----------------------------------------|
| $h=0$   | $a$ dominant, $A$ recessive            |
| $h=1$   | $A$ dominant, $a$ recessive            |
| $0<h<1$ | incomplete dominance                   |
| $h<0$   | overdominance (heterozygote advantage) |
| $h>1$   | underdominance                         |

## The most important equation in population genetics

$$
\Delta_sp = \frac{pq[p(w_{aa} - w_{aA}) + q(w_{aA} - w_{AA})]}{p^2w_{aa} + 2pqw_{aA} + q^2w_{AA}}
$$

```{r }
#| label: allele-frequency-dynamics
#| echo: false
#| eval: true
#| out-height: 400px
#| out-width: 200px
#| fig-width: 8
#| fig-height: 4
dp <- function(h, s, p) {
  q <- 1 - p
  wbar <- 1 - 2 * p * q * h * s - q * q * s
  p * q * s * (p * h + q * (1 - h)) / wbar
}
pevol <- function(p0, n, h, s) {
  p <- vector(length=n, mode="numeric")
  p[1] <- p0
  for (i in 2:n)
    p[i] <- p[i-1] + dp(h, s, p[i-1])
  p
}
p <- seq(0, 1, 0.01)
data <- as.data.frame(rbind(
    data.frame(dp=dp(0.5, 0.1, p), h=0.5, p, selection="directional"),
    data.frame(dp=dp(-0.5, 0.1, p), h=-0.5, p, selection="balancing"),
    data.frame(dp=dp(1.5, 0.1, p), h=1.5, p, selection="disruptive")
))
data$selection <- factor(data$selection,
                         levels=c("directional", "balancing",
                                  "disruptive"))
data2 <- as.data.frame(rbind(
    data.frame(p=pevol(0.1, 100, 0.5, 0.1), generation=1:100, h=0.5,
               selection="directional", p0=0.1),
    data.frame(p=pevol(0.1, 100, -0.5, 0.1), generation=1:100, h=-0.5,
               selection="balancing", p0=0.1),
    data.frame(p=pevol(0.9, 100, -0.5, 0.1), generation=1:100, h=-0.5,
               selection="balancing", p0=0.9),
    data.frame(p=pevol(0.24, 100, 1.5, 0.1), generation=1:100, h=-0.5,
               selection="disruptive", p0=0.24),
    data.frame(p=pevol(0.26, 100, 1.5, 0.1), generation=1:100, h=1.5,
               selection="disruptive", p0=0.26)
))
data2$selection <- factor(data2$selection,
                          levels=c("directional", "balancing",
                                   "disruptive"))
data2$p0 <- as.factor(data2$p0)
selnames <- list(
    `directional` = "directional (h=0.5, s=0.1)",
    `balancing` = "balancing (h=-0.5, s=0.1)",
    `disruptive` = "disruptive (h=1.5, s=0.1)"
)
selection_labeller <- function(variable, value) {
  selnames[value]
}
```

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: selection-fig-dp
#| echo: false
#| eval: true
#| out-height: 500
#| out-width: 500
#| fig-height: 8
#| fig-width: 8
ggplot(data, aes(x = p, y = dp)) +
  geom_line(linewidth=1.2) +
  facet_grid(selection ~ ., labeller=selection_labeller) +
  geom_hline(yintercept=0, linetype="twodash")
```

:::

::: {.column width="50%"}

```{r }
#| label: selection-fig-p
#| echo: false
#| eval: true
#| out-height: 500
#| out-width: 500
#| fig-height: 8
#| fig-width: 8
ggplot(data2, aes(x=generation, y=p, linetype=p0)) + geom_line(linewidth=1.2) +
  facet_grid(selection ~ ., labeller=selection_labeller)
```

:::

::::

## Selection and drift - population size matters

:::: {.columns}

::: {.column width="80%"}

```{r }
#| label: fig-selection-and-drift
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 6
#| fig-cap:
#|     The fixation probability relative to the neutral
#|     probability of fixation under the assumption $s<0.1$.
Ne_s <- seq(-2, 2, 0.01)
# Lynch p. 74
thetaf <- 4*Ne_s / (1-exp(-4*Ne_s))
data <- as.data.frame(cbind(Ne_s, thetaf))
ggplot(data, aes(x=Ne_s, y=thetaf)) + geom_line() +
  ylab(expression("Relative fixation probability" ~ theta[f])) +
  xlab(expression(N[e]* s)) + geom_hline(yintercept=1, linetype="dashed") +
  geom_rect(inherit.aes=FALSE, data = data.frame(xstart=c(-0.1), xend=c(0.1)),
            aes(xmin = xstart, xmax = xend, ymin = -Inf,
                ymax = Inf, fill = "red"), alpha = 0.4,
            show.legend=FALSE)
```

:::

::: {.column width="20%"}

:::

::::

::: {.notes }

Segue: note on the strength of s and the relation to $N_e$.

Even if a new mutation has, say, $s=0.01$, it still needs to overcome
effects of drift. Only has 2% change of fixation.

In figure, we assume $s<0.1$, which is almost always the case.

[@hahn_MolecularPopulationGenetics_2019, p. 133]

:::

## Substitutions and direct selection

:::: {.columns}

::: {.column width="50%"}

**$\mathbf{d_N/d_S << 1}$**
: negative (purifying) selection

**$\mathbf{d_N/d_S < 1}$**
: majority nonsynonymous deleterious, some advantageous

**$\mathbf{d_N/d_S = 1}$**
: neutral or mix neutral / advantageous / deleterious mutations

**$\mathbf{d_N/d_S > 1}$**
: positive selection

:::

::: {.column width="50%"}

```{r }
#| label: fig-ensembl-hsapiens-rat-dnds
#| echo: false
#| eval: true
#| out-height: 400
#| fig-width: 8
#| fig-height: 6
#| fig-cap: $d_n/d_s$ comparisons for human-rat orthologs.
fn <- "assets/data/hsapiens_rat.dnds.tsv"
if (!file.exists(fn)) {
  library(biomaRt)
  ensembl = useEnsembl(version = 99,
                       biomart = 'ENSEMBL_MART_ENSEMBL',
                       dataset = 'hsapiens_gene_ensembl')
  genes <- getBM(mart=ensembl, attributes=c("ensembl_gene_id"))
  hsapiens_rat <- getBM(attributes=c("ensembl_gene_id",
                                     "rnorvegicus_homolog_ensembl_gene",
                                     "rnorvegicus_homolog_dn",
                                     "rnorvegicus_homolog_ds",
                                     "rnorvegicus_homolog_orthology_type"),
                        filters="ensembl_gene_id",
                        values=genes$ensembl_gene_id,
                        mart=ensembl)
  hsapiens_rat <- subset(hsapiens_rat,
                         !is.na(rnorvegicus_homolog_ds) &
                         !is.na(rnorvegicus_homolog_dn) &
                         rnorvegicus_homolog_orthology_type == "ortholog_one2one")
  hsapiens_rat$dnds <- hsapiens_rat$rnorvegicus_homolog_dn /
    hsapiens_rat$rnorvegicus_homolog_ds
  hsapiens_rat <- subset(hsapiens_rat, !is.nan(dnds))
  write.table(hsapiens_rat, file="assets/data/hsapiens_rat.dnds.tsv",
              sep="\t", quote=FALSE, row.names=FALSE)
}
x <- read.table(fn, header=TRUE)
ggplot(x, aes(x=dnds)) +
  geom_histogram(bins=100, aes(y=..count../sum(..count..)), fill="white",
                 color="black") + xlim(0, 2) +
  xlab(expression(d[n]~"/"~d[s])) + ylab("Frequency") +
  ggtitle(paste0(nrow(x), " human-rat orthologue pairs"))
```

:::

::::

::: {.fragment}

<div style="transform: translate(0, -50px);">

Not all mutations fall in genes. Methods for detecting direct
selection not applicable to studying selection on *single* mutation,
or e.g., balancing. This requires looking for specific patterns of
diversity surrounding locus under selection.

</div>

:::

::: {.notes }

Segue: how do we detect selection?

Not all mutations in genes. Also want to look at single advantageous
mutations, or balanced polymorphisms. Must therefore look at tell-tale
signs of linked neutral variants.

:::

## Linked selection

```{r, engine='tikz', fig.ext='svg' }
#| label: fig-selective-sweep
#| echo: false
#| eval: true
#| out-height: 300
#| fig-cap: A selective sweep of an advantageous mutation (gray dot).
\begin{tikzpicture}
  \tikzstyle{mut} = [circle, minimum height=0.4cm, fill=gray, draw];
  \tikzstyle{neutral} = [circle, minimum height=0.4cm, draw, fill=white];
  \begin{scope}
    \draw (0,0) -- (10,0);
    \node[neutral] at (3, 0) {};
    \node[neutral] at (7, 0) {};
    \draw (0,1) -- (10,1);
    \node[neutral] at (8, 1) {};
    \draw (0,2) -- (10,2);
    \node[neutral] at (2, 2) {};
    \node[neutral] at (3, 2) {};
    \node[neutral] at (4, 2) {};
    \node[neutral] at (9, 2) {};
    \draw (0,3) -- (10,3);
    \node[neutral] at (3, 3) {};
    \node[neutral] at (7, 3) {};
    \draw (0,4) -- (10,4);
    \node[neutral] at (0.5, 4) {};
    \node[neutral] at (7, 4) {};
    \draw (0,5) -- (10,5);
    \node[neutral] at (9, 5) {};
    \node[mut] at (3, 5) {};
    \draw (0,6) -- (10,6);
    \node[neutral] at (2, 6) {};
    \node[neutral] at (5, 6) {};
    \draw (0,7) -- (10,7);
    \node[neutral] at (1, 7) {};
    \node[neutral] at (5, 7) {};
    \draw (0,8) -- (10,8);
    \node[neutral] at (2, 8) {};
    \node[neutral] at (5, 8) {};
    \node[neutral] at (9, 8) {};
    \draw (0,9) -- (10,9);
    \node[neutral] at (2, 9) {};
  \end{scope}

  \draw[->, ultra thick] (11, 5) -- (19, 5);
  \node[font=\bfseries] at (15, 5.5) {\LARGE Many generations};

  \begin{scope}[shift={(20, 0)}]
    \draw (0,0) -- (10,0);
    \node[neutral] at (9, 0) {};
    \node[mut] at (3, 0) {};

    \draw (0,1) -- (10,1);
    \node[neutral] at (9, 1) {};
    \node[mut] at (3, 1) {};

    \draw (0,2) -- (10,2);
\node[neutral] at (9, 2) {};
    \node[mut] at (3, 2) {};

    \draw (0,3) -- (10,3);
    \node[neutral] at (9, 3) {};
    \node[mut] at (3, 3) {};

    \draw (0,4) -- (10,4);
    \node[neutral] at (9, 4) {};
    \node[mut] at (3, 4) {};

    \draw (0,5) -- (10,5);
    \node[neutral] at (9, 5) {};
    \node[mut] at (3, 5) {};

    \draw (0,6) -- (10,6);
    \node[neutral] at (9, 6) {};
    \node[mut] at (3, 6) {};

    \draw (0,7) -- (10,7);
    \node[neutral] at (9, 7) {};
    \node[mut] at (3, 7) {};

    \draw (0,8) -- (10,8);
    \node[neutral] at (9, 8) {};
    \node[mut] at (3, 8) {};

    \draw (0,9) -- (10,9);
    \node[neutral] at (9, 9) {};
    \node[mut] at (3, 9) {};

  \end{scope}
\end{tikzpicture}
```

Previous example showed a selective sweep. If a sweep completes at a
locus, it will become monomorphic.

::: {.notes }

Topologies become important when we discuss sweeps

:::

## Recombination breaks upp association between loci

```{r }
#| label: pgip-load-slim-data
#| echo: false
#| eval: true
data <- tidyr::tibble(read.csv("../../data/results/slim/selective_sweep.w500.csv.gz",
                               header = TRUE))
a <- sum(1 / seq(10 - 1))
data$thetaW <- data$S / a
data_mean <- as.data.frame(data) %>%
  dplyr::select(windows, TajD, pi, S, thetaW) %>%
  group_by(windows) %>%
  summarise(TajD = mean(TajD, na.rm = TRUE),
            pi = mean(pi, na.rm = TRUE), S = mean(S, na.rm = TRUE),
            thetaW = mean(thetaW, na.rm = TRUE)) %>%
  mutate(fn = "mean", pi_minus_thetaW = pi - thetaW)
L <- 1e6
xi <- L / 2
```

```{r }
#| label: fig-pgip-slim-sweep-plot-pi-S
#| echo: false
#| eval: true
#| fig-align: center
#| fig-height: 5
#| fig-width: 10
#| out-width: 600
#| fig-cap:
#|     The effect of a selective sweep on diversity.
#|     The figure shows the mean of 1000 simulations
#|     with the selected locus indicated with an arrow.
x <- data_mean %>% pivot_longer(
  cols = c("pi", "thetaW", "pi_minus_thetaW"),
  names_transform =
    list(name = ~readr::parse_factor(.x, levels = c("pi", "thetaW",
                                                    "pi_minus_thetaW")))
  )
ggplot(x, aes(windows, value, color = name)) +
  geom_segment(aes(x = xi, y = -1, xend = xi, yend = -2.5),
               color = "black", arrow = arrow(length = unit(0.4, "cm"),
                                              type = "closed")) +
  xlab("Chromosomal position") +
  ylab("diversity") +
  geom_line(linewidth = 1) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        legend.title = element_blank()) +
  scale_y_continuous(expand = c(0, 0), limits = c(-2.5, 10)) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, L)) +
  scale_colour_manual(
    name = "name", values = c("blue", "red", "green"),
    labels = expression("diversity "~pi, theta[W], pi - theta[W])
  )
```

## Distinguishing selection from drift via topology

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: wf-model-drift-genealogy
#| echo: false
#| eval: true
#| out-height: 600
set.seed(181)
ngen <- 50
n <- 30
wf <- wright_fisher_pop(n = 30, generations = 50, p0=1, init_gen=5)
samples <- sort(sample(which(V(wf)$y == (ngen - 1)), 10))
obj <- wf
i <- V(obj)[unlist(ego(obj, order = ngen - 7, nodes = samples, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele),
                  color = "black", shape = 21, size = 1.5) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.1, 1)) +
  scale_fill_manual(values = c("a" = "white", "A" = "black")) +
  ggtitle("drift")
```

:::

::: {.column width="50%"}

```{r }
#| label: wf-model-selection-genealogy
#| echo: false
#| eval: true
#| out-height: 600
set.seed(1232)
ngen <- 50
n <- 30
wf <- wright_fisher_pop(n = n, generations = ngen, p0=1, init_gen=5, s=.2)
#samples <- sort(sample(which(V(wf)$y == (ngen - 1)), 12))
obj <- wf
i <- V(obj)[unlist(ego(obj, order = 43, nodes = samples, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele),
                  color = "black", shape = 21, size = 1.5) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_fill_manual(values = c("a" = "white", "A" = "black")) +
  scale_y_reverse() + scale_edge_width(range = c(.1, 1)) +
  ggtitle("selection")
```

:::

::::

::: {.notes }

Topology for selection more compressed.

:::

## The phases of a selective sweep

```{R, engine="tikz", fig.ext="svg" }
#| label: fig-selective-sweep-phases
#| echo: false
#| eval: true
#| out-height: 500
#| fig-cap:
#|     Time goes from left to right. As sweep progresses,
#|     tree topology changes. Adapted from
#|     @hahn_MolecularPopulationGenetics_2019, Figure 8.1
\begin{tikzpicture}[inner sep=0, outer sep=0, thick]
\tikzstyle{neutral} = [circle, minimum height=0.4cm, draw, fill=white];
\tikzstyle{mut} = [circle, minimum height=0.4cm, fill=black, draw];
  \begin{scope}
  \path (0, 0) node (a1) {}
  (1, 0) node (a2) {}
  (2, 0) node (a3) {}
  (3, 0) node (a4) {}
  (4, 0) node (a5) {}
  (5, 0) node (a6) {};
\node (a7) at ($(a1) !.5! (a2) + (0, 1)$) {};
\node (a8) at ($(a1-|a7) !.5! (a3) + (0, 3)$) {};
\node (a9) at ($(a4) !.5! (a5) + (0, 4)$) {};
\node (a10) at ($(a1-|a9) !.5! (a6) + (0, 6)$) {};
\node (a11) at ($(a1-|a8) !.5! (a1-|a10) + (0, 10)$) {};
  \draw (a1) -- (a7)
(a2) -- (a7)
(a7) -- (a8)
(a3) -- (a8)
(a4) -- (a9)
(a5) -- (a9)
(a6) -- (a10)
(a9) -- (a10)
(a10) -- (a11)
(a8) -- (a11)
;
\node[mut] at ($(a6) !.1! (a10)$) {};
\draw (0, -2) -- (6, -2)
(0, -3) -- (6, -3)
(0, -4) -- (6, -4)
(0, -5) -- (6, -5)
(0, -6) -- (6, -6)
(0, -7) -- (6, -7)
;
\node[neutral] at (5, -2) {};
\node[mut] at (4, -3) {};
\node[neutral] at (2, -3) {};
\node[neutral] at (5, -3) {};
\node[neutral] at (2, -4) {};
\node[neutral] at (1, -5) {};
\node[neutral] at (3, -5) {};
\node[neutral] at (1, -6) {};
\node[neutral] at (5, -6) {};
\node[neutral] at (1, -7) {};

\end{scope}
  \begin{scope}[xshift=8cm]
  \path (0, 0) node (a1) {}
  (2, 0) node (a2) {}
  (4, 0) node (a3) {}
  (4.5, 0) node (a4) {}
  (5, 0) node (a5) {}
  (5.5, 0) node (a6) {};
\node (a7) at ($(a1) !.5! (a2) + (0, 3)$) {};
\node (a8) at ($(a3) !.5! (a6) + (0, 2)$) {};
\node (a9) at ($(a1-|a8) !.5! (a1-|a8) + (0, 10)$) {};
  \draw (a1) -- (a7)
(a2) -- (a7)
(a3) -- (a8)
(a4) -- (a8)
(a5) -- (a8)
(a6) -- (a8)
(a8) -- (a9)
(a7) -- (a9);
\node[mut] at ($(a8) !.1! (a9)$) {};
\draw (0, -2) -- (6, -2)
(0, -3) -- (6, -3)
(0, -4) -- (6, -4)
(0, -5) -- (6, -5)
(0, -6) -- (6, -6)
(0, -7) -- (6, -7)
;
\node[neutral] at (2, -2) {};
\node[mut] at (4, -2) {};
\node[neutral] at (5, -2) {};
\node[neutral] at (2, -3) {};
\node[mut] at (4, -3) {};
\node[neutral] at (5, -3) {};
\node[neutral] at (2, -4) {};
\node[mut] at (4, -5) {};
\node[neutral] at (5, -4) {};
\node[neutral] at (2, -5) {};
\node[mut] at (4, -4) {};
\node[neutral] at (5, -5) {};
\node[neutral] at (1, -6) {};
\node[neutral] at (5, -6) {};
\node[neutral] at (1, -7) {};
\node[neutral] at (3, -7) {};
    \end{scope}

  \begin{scope}[xshift=16cm]
  \path (1.5, 0) node (a1) {}
  (2, 0) node (a2) {}
  (2.5, 0) node (a3) {}
  (3, 0) node (a4) {}
  (3.5, 0) node (a5) {}
  (4, 0) node (a6) {};
\node (a7) at ($(a1) !.5! (a6) + (0, 1)$) {};
\node (a8) at ($(a7) + (0, 9)$) {};
  \draw (a1) -- (a7)
(a2) -- (a7)
(a3) -- (a7)
(a3) -- (a7)
(a4) -- (a7)
(a5) -- (a7)
(a6) -- (a7)
(a7) -- (a8);
\node[mut] at ($(a7) !.1! (a8)$) {};
\draw (0, -2) -- (6, -2)
(0, -3) -- (6, -3)
(0, -4) -- (6, -4)
(0, -5) -- (6, -5)
(0, -6) -- (6, -6)
(0, -7) -- (6, -7)
;
\node[neutral] at (2, -2) {};
\node[mut] at (4, -2) {};
\node[neutral] at (5, -2) {};
\node[neutral] at (2, -3) {};
\node[mut] at (4, -3) {};
\node[neutral] at (5, -3) {};
\node[neutral] at (2, -4) {};
\node[mut] at (4, -4) {};
\node[neutral] at (5, -4) {};
\node[neutral] at (2, -5) {};
\node[mut] at (4, -5) {};
\node[neutral] at (5, -5) {};
\node[neutral] at (2, -6) {};
\node[mut] at (4, -6) {};
\node[neutral] at (5, -6) {};
\node[neutral] at (2, -7) {};
\node[mut] at (4, -7) {};
\node[neutral] at (5, -7) {};

    \end{scope}

\end{tikzpicture}
```

## Hitchhiking versus background selection

<br>

```{r, engine='tikz', fig.ext='svg' }
#| label: fig-hitchhiking-vs-background-selection
#| echo: false
#| eval: true
#| out-width: 800
#| fig-cap: Hitchhiking (left) versus background selection (right).
\begin{tikzpicture}
  \tikzstyle{mut} = [circle, minimum height=0.4cm, fill=gray, draw];
  \tikzstyle{neutral} = [circle, minimum height=0.4cm, draw, fill=white];

\begin{scope}
    \draw (0,0) -- (10,0);
    \node[neutral] at (3, 0) {};
    \node[neutral] at (7, 0) {};
    \draw (0,1) -- (10,1);
    \node[neutral] at (8, 1) {};
    \draw (0,2) -- (10,2);
    \node[neutral] at (2, 2) {};
    \node[neutral] at (3, 2) {};
    \node[neutral] at (4, 2) {};
    \node[neutral] at (9, 2) {};
    \draw (0,3) -- (10,3);
    \node[neutral] at (3, 3) {};
    \node[neutral] at (7, 3) {};
    \draw (0,4) -- (10,4);
    \node[neutral] at (0.5, 4) {};
    \node[neutral] at (7, 4) {};
    \draw (0,5) -- (10,5);
    \node[neutral] at (9, 5) {};
    \node[mut] at (3, 5) {};
    \draw (0,6) -- (10,6);
    \node[neutral] at (2, 6) {};
    \node[neutral] at (5, 6) {};
    \draw (0,7) -- (10,7);
    \node[neutral] at (1, 7) {};
    \node[neutral] at (5, 7) {};
    \draw (0,8) -- (10,8);
    \node[neutral] at (2, 8) {};
    \node[neutral] at (5, 8) {};
    \node[neutral] at (9, 8) {};
    \draw (0,9) -- (10,9);
    \node[neutral] at (2, 9) {};
  \end{scope}

  \draw[->, ultra thick] (11, 5) -- (14, 5);

  \begin{scope}[shift={(15, 0)}]
    \draw (0,0) -- (10,0);
    \node[neutral] at (9, 0) {};
    \node[mut] at (3, 0) {};

    \draw (0,1) -- (10,1);
    \node[neutral] at (9, 1) {};
    \node[mut] at (3, 1) {};

    \draw (0,2) -- (10,2);
\node[neutral] at (9, 2) {};
    \node[mut] at (3, 2) {};

    \draw (0,3) -- (10,3);
    \node[neutral] at (9, 3) {};
    \node[mut] at (3, 3) {};

    \draw (0,4) -- (10,4);
    \node[neutral] at (9, 4) {};
    \node[mut] at (3, 4) {};

    \draw (0,5) -- (10,5);
    \node[neutral] at (9, 5) {};
    \node[mut] at (3, 5) {};

    \draw (0,6) -- (10,6);
    \node[neutral] at (9, 6) {};
    \node[mut] at (3, 6) {};

    \draw (0,7) -- (10,7);
    \node[neutral] at (9, 7) {};
    \node[mut] at (3, 7) {};

    \draw (0,8) -- (10,8);
    \node[neutral] at (9, 8) {};
    \node[mut] at (3, 8) {};

    \draw (0,9) -- (10,9);
    \node[neutral] at (9, 9) {};
    \node[mut] at (3, 9) {};

\end{scope}

  \begin{scope}[shift={(35, 0)}]
    \draw (0,0) -- (10, 0);
    \node[neutral] at (3, 0) {};
\node[neutral] at (7, 0) {};
    \node[mut] at (9, 0) {};
\draw (0,1) -- (10,1);
    \node[neutral] at (7, 1) {};
    \node[neutral] at (8, 1) {};
    \draw (0,2) -- (10,2);
    \node[neutral] at (3, 2) {};
    \node[neutral] at (4, 2) {};
    \node[neutral] at (9, 2) {};
    \draw (0,3) -- (10,3);
    \node[mut] at (3, 3) {};
    \node[neutral] at (7, 3) {};
    \draw (0,4) -- (10,4);
\node[neutral] at (0.5, 4) {};
\node[neutral] at (3.5, 4) {};
    \node[neutral] at (8.5, 4) {};
    \node[neutral] at (7, 4) {};
    \draw (0,5) -- (10,5);
    \node[neutral] at (5, 5) {};
    \node[neutral] at (4, 5) {};
    \draw (0,6) -- (10,6);
    \node[neutral] at (2, 6) {};
    \draw (0,7) -- (10,7);
    \node[neutral] at (5, 7) {};
    \node[neutral] at (8, 7) {};
    \draw (0,8) -- (10,8);
    \node[neutral] at (2, 8) {};
    \node[neutral] at (4, 8) {};
    \node[mut] at (7, 8) {};
    \draw (0,9) -- (10,9);
\node[neutral] at (2, 9) {};
\node[neutral] at (9, 9) {};
  \end{scope}

  \draw[->, ultra thick] (46, 5) -- (49, 5);

  \begin{scope}[shift={(50, 0)}]
    \draw (0,0) -- (10, 0);
    \node[neutral] at (3, 0) {};
\node[neutral] at (7, 0) {};
\draw (0,1) -- (10,1);
    \node[neutral] at (7, 1) {};
    \node[neutral] at (8, 1) {};
    \draw (0,2) -- (10,2);
    \node[neutral] at (3, 2) {};
    \node[neutral] at (4, 2) {};
    \node[neutral] at (9, 2) {};
    \draw (0,3) -- (10,3);
    \node[mut] at (3, 3) {};
    \node[neutral] at (7, 3) {};
    \draw (0,4) -- (10,4);
    \node[neutral] at (5, 4) {};
    \node[neutral] at (4, 4) {};
    \draw (0,5) -- (10,5);
    \node[neutral] at (5, 5) {};
    \node[neutral] at (4, 5) {};
    \draw (0,6) -- (10,6);
    \node[neutral] at (2, 6) {};
    \draw (0,7) -- (10,7);
    \node[neutral] at (5, 7) {};
    \node[neutral] at (8, 7) {};
    \draw (0,8) -- (10,8);
    \node[neutral] at (2, 8) {};
    \node[neutral] at (9, 8) {};
    \draw (0,9) -- (10,9);
    \node[neutral] at (2, 9) {};
    \node[neutral] at (9, 9) {};
  \end{scope}

\end{tikzpicture}
```

## Summary

We have looked at the **Wright-Fisher model** as a model of populations and **genealogies***

**Genetic drift** moves allele frequencies up and down at random and
removes variation at rate $\propto 1/2N$

**Mutation** reintroduces variation. The **Neutral theory** posits
most mutations are neutral and dynamics follow **mutation drift**
equilibrium.

Methods to detect **selection** are based on **direct selection** or
studying patterns of variation caused by **linked selection**.

## Bibliography {.unnumbered .unlisted}

::: { #refs }
:::
